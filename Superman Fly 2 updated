--== CONFIG / STATE ==--
local savedSpeed = 60
local boostEnabled = false
local flying = false
local baseSpeed = savedSpeed
local flySpeed = baseSpeed
local forwardHold = 0
local inputFlags = { forward = false, back = false, left = false, right = false, up = false, down = false }

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local character, humanoid, HRP

local bodyVelocity, bodyGyro
local screenGui, toggleButton, speedBox
local animations, tracks = {}, {}

local gyroSmoothness = 10

-- Anti-interrupt state
local protectionLoop = nil
local savedProperties = {} -- stores original character state for clean restore

--== CAMERA FOV HANDLING ==--
local defaultFOV = Camera.FieldOfView
local targetFOV = defaultFOV
local tweenFOV

local function setFOV(newFOV)
	if tweenFOV then tweenFOV:Cancel() end
	targetFOV = newFOV
	tweenFOV = TweenService:Create(Camera, TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {FieldOfView = targetFOV})
	tweenFOV:Play()
end

local function updateFOV()
	local fov = defaultFOV
	if flying then fov = fov + 10 end
	if boostEnabled then fov = fov + 20 end
	setFOV(fov)
end

--== ANIMS ==--
local function newAnim(id)
	local anim = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://" .. id
	return anim
end

local function setupAnimations()
	animations = {
		forward = newAnim(90872539),
		up = newAnim(90872539),
		right1 = newAnim(136801964),
		right2 = newAnim(142495255),
		left1 = newAnim(136801964),
		left2 = newAnim(142495255),
		flyLow1 = newAnim(97169019),
		flyLow2 = newAnim(282574440),
		flyFast = newAnim(282574440),
		back1 = newAnim(214744412),
		back2 = newAnim(214744412),
		back3 = newAnim(214744412),
		back4 = newAnim(214744412),
		down = newAnim(233322916),
		idle1 = newAnim(97171309),
		idleHover = newAnim(313762630)
	}
	tracks = {}
	for name, anim in pairs(animations) do
		tracks[name] = humanoid:LoadAnimation(anim)
	end
end

local function stopAll()
	for _, track in pairs(tracks) do
		if track and track.IsPlaying then
			track:Stop(0.25)
		end
	end
end

--== ANTI-INTERRUPT: Aggressively maintain physics objects ==--
local function nukeExternalForces()
	if not HRP then return end
	-- Destroy any BodyMovers that aren't ours
	for _, obj in ipairs(HRP:GetChildren()) do
		if (obj:IsA("BodyVelocity") or obj:IsA("BodyForce") or obj:IsA("BodyPosition")
			or obj:IsA("BodyThrust") or obj:IsA("VectorForce") or obj:IsA("LinearVelocity")
			or obj:IsA("AlignPosition") or obj:IsA("AlignOrientation")
			or obj:IsA("BodyAngularVelocity")) then
			-- Only destroy if it's NOT our fly objects
			if obj ~= bodyVelocity and obj ~= bodyGyro then
				obj:Destroy()
			end
		end
	end
end

local function ensurePhysics()
	if not HRP then return end

	-- If our BodyVelocity got destroyed or reparented, recreate it
	if not bodyVelocity or not bodyVelocity.Parent or bodyVelocity.Parent ~= HRP then
		if bodyVelocity then pcall(function() bodyVelocity:Destroy() end) end
		bodyVelocity = Instance.new("BodyVelocity")
		bodyVelocity.Name = "SUPERMAN_VEL"
		bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
		bodyVelocity.Velocity = Vector3.zero
		bodyVelocity.P = 10000
		bodyVelocity.Parent = HRP
	else
		-- Force max force every frame in case something changed it
		bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	end

	-- Same for BodyGyro
	if not bodyGyro or not bodyGyro.Parent or bodyGyro.Parent ~= HRP then
		if bodyGyro then pcall(function() bodyGyro:Destroy() end) end
		bodyGyro = Instance.new("BodyGyro")
		bodyGyro.Name = "SUPERMAN_GYRO"
		bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
		bodyGyro.CFrame = Camera.CFrame
		bodyGyro.P = 5000
		bodyGyro.D = 300
		bodyGyro.Parent = HRP
	else
		bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
	end
end

local function forceHumanoidState()
	if not humanoid then return end
	-- Keep PlatformStand true no matter what
	humanoid.PlatformStand = true

	-- Override any state changes that would ground us
	pcall(function()
		if humanoid:GetState() ~= Enum.HumanoidStateType.Physics
			and humanoid:GetState() ~= Enum.HumanoidStateType.PlatformStanding then
			humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		end
	end)

	-- Prevent ragdoll / fling by zeroing out assembly velocity if we control it
	-- (we set velocity ourselves each frame so this just prevents external spikes)
end

local function disableCharacterCollisions()
	if not character then return end
	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			-- Save original state
			if not savedProperties[part] then
				savedProperties[part] = {
					CanCollide = part.CanCollide,
					Massless = part.Massless,
				}
			end
			-- Make massless so external forces have less effect
			part.Massless = true
		end
	end
end

local function restoreCharacterCollisions()
	for part, props in pairs(savedProperties) do
		if part and part.Parent then
			pcall(function()
				part.CanCollide = props.CanCollide
				part.Massless = props.Massless
			end)
		end
	end
	savedProperties = {}
end

--== START / STOP FLYING ==--
local animateScript
local stateChangedConn
local ancestryConnections = {}

local function startFlying()
	flying = true
	forwardHold = 0
	flySpeed = baseSpeed

	-- Save and disable Animate script
	if not animateScript and character then
		animateScript = character:FindFirstChild("Animate")
	end
	if animateScript then
		animateScript.Enabled = false
	end

	-- Disable humanoid states that could interrupt flight
	pcall(function()
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
	end)

	-- Make character parts massless
	disableCharacterCollisions()

	-- Create physics
	ensurePhysics()
	humanoid.PlatformStand = true
	updateFOV()

	-- Monitor if our physics objects get destroyed (anti-tamper)
	-- BodyVelocity ancestry watch
	for _, conn in ipairs(ancestryConnections) do
		pcall(function() conn:Disconnect() end)
	end
	ancestryConnections = {}

	if bodyVelocity then
		local conn = bodyVelocity.AncestryChanged:Connect(function(_, newParent)
			if flying and (not newParent or newParent ~= HRP) then
				task.defer(ensurePhysics)
			end
		end)
		table.insert(ancestryConnections, conn)
	end
	if bodyGyro then
		local conn = bodyGyro.AncestryChanged:Connect(function(_, newParent)
			if flying and (not newParent or newParent ~= HRP) then
				task.defer(ensurePhysics)
			end
		end)
		table.insert(ancestryConnections, conn)
	end

	-- State change listener - force back to physics state
	if stateChangedConn then pcall(function() stateChangedConn:Disconnect() end) end
	stateChangedConn = humanoid.StateChanged:Connect(function(_, newState)
		if not flying then return end
		if newState ~= Enum.HumanoidStateType.Physics
			and newState ~= Enum.HumanoidStateType.PlatformStanding then
			task.defer(function()
				if flying and humanoid then
					humanoid.PlatformStand = true
					pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Physics) end)
				end
			end)
		end
	end)

	-- Protection loop: runs every 0.1s as backup
	if protectionLoop then pcall(function() protectionLoop:Disconnect() end) end
	local protectionTimer = 0
	protectionLoop = RunService.Heartbeat:Connect(function(dt)
		if not flying then return end
		protectionTimer = protectionTimer + dt
		if protectionTimer < 0.1 then return end
		protectionTimer = 0

		-- Re-ensure physics exist
		ensurePhysics()
		-- Kill external forces
		nukeExternalForces()
		-- Force humanoid state
		forceHumanoidState()
		-- Keep parts massless
		if character then
			for _, part in ipairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Massless = true
				end
			end
		end
	end)
end

local function stopFlying()
	flying = false

	-- Stop protection loop
	if protectionLoop then
		protectionLoop:Disconnect()
		protectionLoop = nil
	end

	-- Disconnect state watcher
	if stateChangedConn then
		stateChangedConn:Disconnect()
		stateChangedConn = nil
	end

	-- Disconnect ancestry watchers
	for _, conn in ipairs(ancestryConnections) do
		pcall(function() conn:Disconnect() end)
	end
	ancestryConnections = {}

	-- Remove physics objects cleanly
	if bodyVelocity then
		pcall(function() bodyVelocity:Destroy() end)
		bodyVelocity = nil
	end
	if bodyGyro then
		pcall(function() bodyGyro:Destroy() end)
		bodyGyro = nil
	end

	-- Restore humanoid to fully normal state
	if humanoid then
		humanoid.PlatformStand = false

		pcall(function()
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
		end)

		-- Force back to running state
		pcall(function()
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		end)
		task.delay(0.1, function()
			if humanoid and not flying then
				pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Running) end)
			end
		end)
	end

	-- Restore character part properties
	restoreCharacterCollisions()

	-- Stop animations
	stopAll()

	-- Restore FOV
	updateFOV()

	-- Re-enable Animate
	if animateScript then
		animateScript.Enabled = true
	end

	-- Zero out any residual velocity so player doesn't fling
	if HRP then
		pcall(function()
			HRP.AssemblyLinearVelocity = Vector3.zero
			HRP.AssemblyAngularVelocity = Vector3.zero
		end)
	end
end

--== GUI ==--
local function createGui()
	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "FlyScreenGui"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = player:WaitForChild("PlayerGui")

	toggleButton = Instance.new("TextButton")
	toggleButton.Text = "Fly OFF"
	toggleButton.Size = UDim2.new(0, 100, 0, 50)
	toggleButton.Position = UDim2.new(1, -220, 0, 10)
	toggleButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	toggleButton.Font = Enum.Font.GothamBold
	toggleButton.TextScaled = true
	toggleButton.BackgroundTransparency = 0.2
	toggleButton.Parent = screenGui

	speedBox = Instance.new("TextBox")
	speedBox.Text = tostring(baseSpeed)
	speedBox.Size = UDim2.new(0, 100, 0, 50)
	speedBox.Position = UDim2.new(1, -110, 0, 10)
	speedBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	speedBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	speedBox.Font = Enum.Font.GothamBold
	speedBox.TextScaled = true
	speedBox.BackgroundTransparency = 0.2
	speedBox.Parent = screenGui

	toggleButton.MouseButton1Click:Connect(function()
		if flying then
			stopFlying()
			toggleButton.Text = "Fly OFF"
		else
			startFlying()
			toggleButton.Text = "Fly ON"
		end
	end)

	speedBox.FocusLost:Connect(function()
		local num = tonumber(speedBox.Text)
		if num and num > 0 then
			baseSpeed = num
			savedSpeed = num
			if flying then flySpeed = baseSpeed end
		else
			speedBox.Text = tostring(baseSpeed)
		end
	end)
end

--== INPUT ==--
local function bindInput()
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		local k = input.KeyCode

		if k == Enum.KeyCode.W then inputFlags.forward = true end
		if k == Enum.KeyCode.S then inputFlags.back = true end
		if k == Enum.KeyCode.A then inputFlags.left = true end
		if k == Enum.KeyCode.D then inputFlags.right = true end
		if k == Enum.KeyCode.E then inputFlags.up = true end
		if k == Enum.KeyCode.Q then inputFlags.down = true end

		if k == Enum.KeyCode.T then
			if flying then
				stopFlying()
				if toggleButton then toggleButton.Text = "Fly OFF" end
			else
				startFlying()
				if toggleButton then toggleButton.Text = "Fly ON" end
			end
		end

		if k == Enum.KeyCode.LeftControl then
			boostEnabled = true
			updateFOV()
		end
	end)

	UserInputService.InputEnded:Connect(function(input)
		local k = input.KeyCode

		if k == Enum.KeyCode.W then inputFlags.forward = false end
		if k == Enum.KeyCode.S then inputFlags.back = false end
		if k == Enum.KeyCode.A then inputFlags.left = false end
		if k == Enum.KeyCode.D then inputFlags.right = false end
		if k == Enum.KeyCode.E then inputFlags.up = false end
		if k == Enum.KeyCode.Q then inputFlags.down = false end

		if k == Enum.KeyCode.LeftControl then
			boostEnabled = false
			updateFOV()
		end
	end)
end

--== MAIN LOOP ==--
RunService.RenderStepped:Connect(function(dt)
	if not flying then return end
	if not character or not character:IsDescendantOf(workspace) then return end
	if not humanoid or not HRP then return end

	-- Aggressively ensure our physics objects exist every single frame
	ensurePhysics()

	-- Force humanoid state every frame
	humanoid.PlatformStand = true

	local dir = Vector3.zero
	local camCF = Camera.CFrame

	if inputFlags.forward then dir += camCF.LookVector end
	if inputFlags.back then dir -= camCF.LookVector end
	if inputFlags.left then dir -= camCF.RightVector end
	if inputFlags.right then dir += camCF.RightVector end
	if inputFlags.up then dir += Vector3.yAxis end
	if inputFlags.down then dir -= Vector3.yAxis end

	if dir.Magnitude > 0 then dir = dir.Unit end

	flySpeed = baseSpeed
	if inputFlags.forward then
		forwardHold += dt
		if forwardHold >= 0.1 then
			flySpeed = baseSpeed * 1.3
		end
	else
		forwardHold = 0
	end

	local currentSpeed = flySpeed
	if boostEnabled then currentSpeed += 100 end

	-- Set velocity directly - math.huge MaxForce ensures nothing overrides this
	bodyVelocity.Velocity = dir * currentSpeed

	-- Also directly override assembly velocity as backup
	-- This catches cases where server-side forces try to override
	if dir.Magnitude > 0 then
		HRP.AssemblyLinearVelocity = dir * currentSpeed
	else
		-- When idle, zero velocity and hold position
		HRP.AssemblyLinearVelocity = Vector3.zero
	end

	-- Smooth gyro
	local alpha = 1 - math.exp(-gyroSmoothness * dt)
	bodyGyro.CFrame = bodyGyro.CFrame:Lerp(camCF, alpha)

	-- Kill angular velocity every frame to prevent spinning/tumbling from external hits
	HRP.AssemblyAngularVelocity = Vector3.zero

	-- Anim logic
	if inputFlags.up then
		if not tracks.up.IsPlaying then stopAll(); tracks.up:Play() end
	elseif inputFlags.down then
		if not tracks.down.IsPlaying then stopAll(); tracks.down:Play() end
	elseif inputFlags.left then
		if not tracks.left1.IsPlaying then
			stopAll()
			tracks.left1:Play(); tracks.left1.TimePosition = 2.0; tracks.left1:AdjustSpeed(0)
			tracks.left2:Play(); tracks.left2.TimePosition = 0.5; tracks.left2:AdjustSpeed(0)
		end
	elseif inputFlags.right then
		if not tracks.right1.IsPlaying then
			stopAll()
			tracks.right1:Play(); tracks.right1.TimePosition = 1.1; tracks.right1:AdjustSpeed(0)
			tracks.right2:Play(); tracks.right2.TimePosition = 0.5; tracks.right2:AdjustSpeed(0)
		end
	elseif inputFlags.back then
		if not tracks.back1.IsPlaying then
			stopAll()
			tracks.back1:Play(); tracks.back1.TimePosition = 5.3; tracks.back1:AdjustSpeed(0)
			tracks.back2:Play(); tracks.back2:AdjustSpeed(0)
			tracks.back3:Play(); tracks.back3.TimePosition = 0.8; tracks.back3:AdjustSpeed(0)
			tracks.back4:Play(); tracks.back4.TimePosition = 1; tracks.back4:AdjustSpeed(0)
		end
	elseif inputFlags.forward then
		if forwardHold >= 0.1 then
			if not tracks.flyFast.IsPlaying then
				stopAll()
				tracks.flyFast:Play(); tracks.flyFast:AdjustSpeed(0.05)
			end
		else
			if not tracks.flyLow1.IsPlaying then
				stopAll()
				tracks.flyLow1:Play()
				tracks.flyLow2:Play()
			end
		end
	else
		if not (tracks.idle1.IsPlaying and tracks.idleHover.IsPlaying) then
			stopAll()
			tracks.idle1:Play()
			tracks.idle1:AdjustWeight(1)
			tracks.idle1:AdjustSpeed(0)
			tracks.idleHover:Play()
			tracks.idleHover:AdjustWeight(2)
			tracks.idleHover:AdjustSpeed(1)
		end
	end
end)

--== CHAR BIND ==--
local function bindCharacter()
	character = player.Character or player.CharacterAdded:Wait()
	humanoid = character:WaitForChild("Humanoid")
	HRP = character:WaitForChild("HumanoidRootPart")

	setupAnimations()

	if flying then
		task.wait(0.2)
		startFlying()
	end
end

-- Init
createGui()
bindInput()
player.CharacterAdded:Connect(bindCharacter)
bindCharacter()

print("Superman Fly loaded - UNSTOPPABLE mode")
