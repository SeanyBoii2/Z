-- StarterPlayerScripts/ChatControl.lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextChatService = game:GetService("TextChatService")
local LocalPlayer = Players.LocalPlayer

local ownerName = "PINK"

-- ==== STATE ====
local followConn, attackConn
local attacking = false
local isSummoned = false
local roamMode = false
local currentOwner
local currentAttackTarget
local lastCommand = {type=nil, target=nil}
local attackSession = 0

-- ==== UTIL ====
local isLegacyChat = not pcall(function() return TextChatService.TextChannels.RBXGeneral end)

local function chatMessage(str)
	str = tostring(str)
	if not isLegacyChat then
		TextChatService.TextChannels.RBXGeneral:SendAsync(str)
	else
		ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(str,"All")
	end
end

local function normalize(msg)
	if not msg then return "" end
	msg = msg:lower():gsub("^%s*(.-)%s*$","%1")
	msg = msg:gsub("^[/!]+","")
	return msg
end

local function getSelf()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	return char, char:FindFirstChildWhichIsA("Humanoid"), char:FindFirstChild("HumanoidRootPart")
end

local function findOwner()
	for _,plr in ipairs(Players:GetPlayers()) do
		if plr.Name:lower() == ownerName:lower() or plr.DisplayName:lower() == ownerName:lower() then
			return plr
		end
	end
	return nil
end

local function findPlayerByPartialName(partial)
	local lowerPartial = partial:lower()
	for _,plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer then
			if plr.Name:lower():find(lowerPartial,1,true) or plr.DisplayName:lower():find(lowerPartial,1,true) then
				return plr
			end
		end
	end
	return nil
end

-- ==== CLEANUP ====
local function stopFollowing()
	if followConn then followConn:Disconnect() followConn=nil end
end

local function stopAttacking()
	attackSession += 1      -- ‚úÖ invalidate old attack loops
	if attackConn then attackConn:Disconnect() attackConn = nil end
	attacking = false
	currentAttackTarget = nil
end


-- ==== ANCHOR CHARACTER ====
local function anchorCharacter(char)
	if not char then return end
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end
end

--SUMMON--
local function summonToOwner(owner, silent)
	if not owner then return end
	stopFollowing()
	stopAttacking()
	isSummoned = true
	roamMode = false
	currentOwner = owner
	lastCommand = {type="summon", target=nil}

	if not owner.Character then
		owner.CharacterAdded:Wait()
	end
	local oChar = owner.Character or owner.CharacterAdded:Wait()
	local oHRP = oChar:WaitForChild("HumanoidRootPart")
	local char, _, myHRP = getSelf()
	if not myHRP or not oHRP then return end

	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = false
		end
	end

	myHRP.CFrame = oHRP.CFrame * CFrame.new(-2.5,0,3.2)

	followConn = RunService.RenderStepped:Connect(function()
		if oHRP and myHRP and isSummoned and not attacking and not roamMode then
			myHRP.CFrame = oHRP.CFrame * CFrame.new(-2.5,0,3.2)
		else
			stopFollowing()
		end
	end)

	-- Watch for owner respawn
	owner.CharacterAdded:Connect(function(char)
		task.wait(0.5)
		if isSummoned then
			summonToOwner(owner, true)
		end
	end)

	if not silent then
		chatMessage("I'm here ‚Äî following you now.")
	end
end

-- ==== DISMISS ====
local function dismissSelf()
	if not isSummoned and not roamMode then return end
	stopAttacking()
	stopFollowing()
	isSummoned = false
	roamMode = false
	currentOwner = nil

	local char, hum, hrp = getSelf()
	if not hrp then return end

	-- Create invisible platform 200 studs above current position
	local platform = Instance.new("Part")
	platform.Size = Vector3.new(10, 1, 10)
	platform.Anchored = true
	platform.CanCollide = true
	platform.Transparency = 1
	platform.Name = "StandbyPlatform"
	platform.CFrame = hrp.CFrame + Vector3.new(0, 250, 0)
	platform.Parent = workspace

	-- Make sure character isn't sitting
	if hum and hum.SeatPart then
		hum.Sit = false
		task.wait(0.1)
	end

	-- Teleport (goto) the platform, then anchor
	hrp.CFrame = platform.CFrame + Vector3.new(0, 3, 0)
	task.wait(0.5)

	-- Anchor character
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end

	chatMessage("üî∫ Going on standby.")
end


-- ==== DEFEND MODE (edited roam logic) ====
local function roamModeOn()

	-- leave standby / dismiss state
	stopFollowing()
	stopAttacking()

	isSummoned = false
	roamMode = true

	-- UNANCHOR (important if dismissed)
	local char, _, myHRP = getSelf()
	if char then
		for _, part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = false
			end
		end
	end

	local owner = findOwner()
	if not owner or not owner.Character then
		chatMessage("‚ùå Owner not found.")
		return
	end

	local oHRP = owner.Character:FindFirstChild("HumanoidRootPart")
	local oHum = owner.Character:FindFirstChildWhichIsA("Humanoid")

	if not oHRP or not oHum or not myHRP then
		chatMessage("‚ùå Defend failed ‚Äî invalid owner.")
		return
	end

	-- TELEPORT ONCE (like attack)
	myHRP.CFrame = oHRP.CFrame * CFrame.new(0,0,3)

	chatMessage("üõ°Ô∏è Defend mode ‚Äî watching owner's health.")

	local lastHealth = oHum.Health
	local lastDamageTime = os.clock()

	task.spawn(function()
		while roamMode do
			if not oHum.Parent then break end

			-- damage detected ‚Üí reset timer
			if oHum.Health < lastHealth then
				lastDamageTime = os.clock()
				lastHealth = oHum.Health
			else
				lastHealth = oHum.Health
			end

			-- no damage ‚Üí return to follow mode
			if os.clock() - lastDamageTime >= 30 then
				chatMessage("‚úÖ Area secure ‚Äî returning to follow mode.")
				roamMode = false

				local owner = findOwner()
				if owner then summonToOwner(owner, true) end
				break
			end

			task.wait(0.4)
		end
	end)
end




-- ==== ATTACK ====
local function attackPlayer(partialName)

	-- new attack session
	attackSession += 1
	local mySession = attackSession

	-- if switching from an active target
	if attacking and currentAttackTarget then
		chatMessage("üîÅ Switching target to " .. partialName)
	end

	-- OVERRIDE any mode
	stopAttacking()
	stopFollowing()
	isSummoned = true
	roamMode = false


-- UNANCHOR if dismissed
local char = LocalPlayer.Character
if char then
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = false
		end
	end
end

	local target = findPlayerByPartialName(partialName)
	if not target or not target.Character then
		chatMessage("‚ùå Target not found ‚Äî returning to owner.")
		local owner = findOwner()
		if owner then summonToOwner(owner,true) end
		return
	end

	local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
	local tHum = target.Character:FindFirstChildWhichIsA("Humanoid")
	local _,_,myHRP = getSelf()

	if not tHRP or not myHRP then
		chatMessage("‚ùå Target invalid ‚Äî returning to owner.")
		local owner = findOwner()
		if owner then summonToOwner(owner,true) end
		return
	end

	-- mark attack active
	attacking = true
	currentAttackTarget = target.Name
	lastCommand = {type="attack", target=target}

	chatMessage("‚öîÔ∏è Attacking " .. target.DisplayName .. " now.")

	-- teleport once
	myHRP.CFrame = tHRP.CFrame * CFrame.new(0,0,3)

	-- monitor with session check
	task.spawn(function()
		while attacking and mySession == attackSession do

			-- target gone or dead
			if not target.Parent or (tHum and tHum.Health <= 0) then
				local msg = "‚ö™ Target defeated ‚Äî returning to owner."
				if not target.Parent then msg = "‚ö™ Target left ‚Äî returning to owner." end

				-- only return if still current attack
				if mySession == attackSession then
					chatMessage(msg)
					stopAttacking()
					local owner = findOwner()
					if owner then summonToOwner(owner,true) end
				end
				break
			end

			task.wait(0.3)
		end
	end)

end




-- ==== YIELD ====
local function yieldAttack()
	stopAttacking()
	stopFollowing()

	local owner = findOwner()
	if owner then
		summonToOwner(owner,true)
		chatMessage("‚ö™ Returning to owner ‚Äî back to follow mode.")
	end

	isSummoned = true   -- ‚úÖ KEEP FOLLOWING
	roamMode = false   -- ‚úÖ EXIT ROAM
end


--
local function ultimateCommand()
	for i=1,5 do
		VirtualInputManager:SendKeyEvent(true,Enum.KeyCode.G,false,game)
		VirtualInputManager:SendKeyEvent(false,Enum.KeyCode.G,false,game)
		task.wait(0.15)
	end
	chatMessage("üí• Ultimate activated ‚Äî if nothing happens, Ultimate isn't ready yet.")
end


-- ==== HEAL ====
local function healCommand()
	if not isSummoned then return end
	dismissSelf()

	local char, hum, _ = getSelf()
	if hum then
		hum:ChangeState(Enum.HumanoidStateType.Dead)
	else
		char:BreakJoints()
	end

	LocalPlayer.CharacterAdded:Wait()
	task.wait(0.3)

	local saved = lastCommand
	if saved.type == "summon" then
		local owner = findOwner()
		if owner then summonToOwner(owner) end
	elseif saved.type == "attack" and saved.target then
		if saved.target.Parent then
			attackPlayer(saved.target.Name)
		else
			local owner = findOwner()
			if owner then summonToOwner(owner) end
		end
	end

	chatMessage("üíö Healed ‚Äî resuming last action.")
end

-- ==== RESET ====
local function resetCommand()
	dismissSelf()
	local char, hum, _ = getSelf()
	if hum then
		hum:ChangeState(Enum.HumanoidStateType.Dead)
	else
		char:BreakJoints()
	end
	chatMessage("üîÑ Resetting ‚Äî back in action soon.")
end


-- ==== COMMAND LIST ====
local function sendCommandsList()
	local list = "summon ‚Äì Call bot, attack [name] ‚Äì Attack, yield ‚Äì Stop & return, ultimate ‚Äì Use Ultimate, dismiss ‚Äì Standby, defend ‚Äì Guard Owner, reset ‚Äì Reset, cmds ‚Äì Show cmds"
	chatMessage(list)
end

local function isAlive()
	local char, hum = getSelf()
	return hum and hum.Health > 0
end


-- ==== CHAT HANDLER ====
local function handleMessage(fromPlayer,msg)
	if not fromPlayer or not msg then return end

	-- OWNER CHECK
	if fromPlayer.Name:lower() ~= ownerName:lower() and
	   fromPlayer.DisplayName:lower() ~= ownerName:lower() then return end

	-- DEAD CHECK
	if not isAlive() then
		return
	end

	msg = normalize(msg)


	if msg=="dismiss" then
		dismissSelf()

	elseif msg=="summon" then
		summonToOwner(fromPlayer)

	elseif msg=="defend" then
		roamModeOn()

	elseif msg=="reset" then
		resetCommand()

	elseif msg:match("^attack%s+") then
		local targetName = msg:match("^attack%s+(.+)")
		if targetName then attackPlayer(targetName) end

	elseif msg=="yield" then
		yieldAttack()

	elseif msg=="ultimate" then
		ultimateCommand()

	elseif msg=="heal" then
		healCommand()

	elseif msg=="commands" or msg=="cmds" then
		sendCommandsList()

	-- ===========================
	--     NEW CHAR COMMAND
	-- ===========================
	elseif msg:match("^char%s+") then
		local charName = msg:match("^char%s+(.+)")
		if charName then
			charName = charName:lower()

			if charName == "star" then
				chatMessage("‚ú® Changing character to Star Platinum.")
			elseif charName == "world" then
				chatMessage("‚ú® Changing character to The World.")
			elseif charName == "ger" then
				chatMessage("‚ú® Changing character to Gold Experience Requiem.")
			else
				chatMessage("‚ùì Unknown character. Options: star, world, ger.")
			end
		end
	end
end


-- ==== CONNECTIONS ====
for _,p in ipairs(Players:GetPlayers()) do
	p.Chatted:Connect(function(msg) handleMessage(p,msg) end)
end

Players.PlayerAdded:Connect(function(p)
	p.Chatted:Connect(function(msg) handleMessage(p,msg) end)
end)

LocalPlayer.CharacterAdded:Connect(function()
	task.wait(0.5)
	local owner = findOwner()
	if owner then summonToOwner(owner,true) end
end)

task.delay(1,function() chatMessage("Bot ready ‚Äî owner: "..ownerName) end)
print("Listening for owner:",ownerName)
