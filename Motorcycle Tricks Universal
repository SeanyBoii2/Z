--[[
    ╔══════════════════════════════════════════════════════════════╗
    ║               MOTORCYCLE TRICKS GUI SCRIPT                   ║
    ╠══════════════════════════════════════════════════════════════╣
    ║  Created by: spookyie                                        ║
    ║  Discord: spookyie                                           ║
    ║                                                              ║
    ║  Features:                                                   ║
    ║  • Wheelie, Stoppie, Side Wheelie, Back Hop                 ║
    ║  • Jump, Backflip, Frontflip                                ║
    ║  • Auto-Steer with waypoint system                          ║
    ║  • Mouse wheel angle control                                 ║
    ║  • Customizable keybinds (Ctrl/Shift)                       ║
    ║  • Alt quick-switch between Wheelie/Stoppie                 ║
    ║                                                              ║
    ║  Works universally on any vehicle!                          ║
    ╚══════════════════════════════════════════════════════════════╝
]]

local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Configuration
local GYRO_POWER = 10000
local GYRO_DAMPING = 1000
local STABILIZE_FORCE = 20000
local ROTATION_SPEED = 1

-- State
local currentMode = "Wheelie"
local isActive = false
local motorcycle = nil
local bodyGyro = nil
local bodyPosition = nil
local updateConnection = nil
local targetYRotation = 0
local originalNeutralCFrame = nil
local autoSteerEnabled = false
local autoSteerConnection = nil
local waypointMarker = nil
local waypointPosition = nil
local mouseWheelControlEnabled = false
local activationKey = Enum.KeyCode.LeftControl
local MOUSE_WHEEL_SENSITIVITY = 8
local autoSwitchEnabled = false
local backHopConnection = nil

-- Mode settings
local modeSettings = {
	Wheelie = { angle = 45, minAngle = 10, maxAngle = 80 },
	Stoppie = { angle = 45, minAngle = 10, maxAngle = 80 },
	SideWheelie = { angle = 45, minAngle = 10, maxAngle = 80, tilt = 30, minTilt = 10, maxTilt = 60 },
	BackHop = { angle = 55, hopPower = 30, minHopPower = 15, maxHopPower = 80, hopInterval = 0.4 },
	Jump = { power = 50, minPower = 50, maxPower = 300 },
	Backflip = { speed = 3, minSpeed = 1, maxSpeed = 8 },
	Frontflip = { speed = 3, minSpeed = 1, maxSpeed = 8 },
	AutoSteer = { strength = 5, minStrength = 1, maxStrength = 10 }
}

------------------------------------------------------
--               VEHICLE LOGIC (unchanged)          --
------------------------------------------------------

local function findMotorcycle()
	local tool = character:FindFirstChildOfClass("Tool")
	if tool then return tool end
	if character.Humanoid.SeatPart then
		return character.Humanoid.SeatPart.Parent
	end
	return nil
end

local function doTrick()
	if currentMode == "Jump" then
		motorcycle = findMotorcycle()
		if not motorcycle then return end
		local mainPart = motorcycle:FindFirstChild("MainPart") or motorcycle.PrimaryPart
		if not mainPart then return end
		local bodyVelocity = Instance.new("BodyVelocity")
		bodyVelocity.Name = "JumpVelocity"
		bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
		bodyVelocity.Velocity = Vector3.new(0, modeSettings.Jump.power, 0)
		bodyVelocity.Parent = mainPart
		task.delay(0.2, function()
			if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end
		end)
		return
	end

	if currentMode == "Backflip" then
		motorcycle = findMotorcycle()
		if not motorcycle then return end
		local mainPart = motorcycle:FindFirstChild("MainPart") or motorcycle.PrimaryPart
		if not mainPart then return end
		local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
		bodyAngularVelocity.Name = "FlipVelocity"
		bodyAngularVelocity.MaxTorque = Vector3.new(math.huge, 0, 0)
		bodyAngularVelocity.AngularVelocity = Vector3.new(modeSettings.Backflip.speed, 0, 0)
		bodyAngularVelocity.P = 10000
		bodyAngularVelocity.Parent = mainPart
		bodyGyro = bodyAngularVelocity
		return
	end

	if currentMode == "BackHop" then
		motorcycle = findMotorcycle()
		if not motorcycle then return end
		local mainPart = motorcycle:FindFirstChild("MainPart") or motorcycle.PrimaryPart
		if not mainPart then return end
		if not bodyGyro or not bodyGyro.Parent then
			bodyGyro = Instance.new("BodyGyro")
			bodyGyro.Name = "BackHopGyro"
			bodyGyro.MaxTorque = Vector3.new(GYRO_POWER, GYRO_POWER, GYRO_POWER)
			bodyGyro.P = GYRO_POWER
			bodyGyro.D = GYRO_DAMPING
			bodyGyro.Parent = mainPart
		end
		local initialCFrame = mainPart.CFrame
		local _, initialY, _ = initialCFrame:ToOrientation()
		if backHopConnection then backHopConnection:Disconnect() end
		local lastHopTime = 0
		backHopConnection = RunService.Heartbeat:Connect(function()
			if not isActive or currentMode ~= "BackHop" then
				if backHopConnection then backHopConnection:Disconnect(); backHopConnection = nil end
				return
			end
			if not mainPart or not mainPart.Parent then return end
			local wheelieAngle = modeSettings.BackHop.angle
			local targetCFrame = CFrame.new(mainPart.Position) * CFrame.Angles(0, initialY, 0) * CFrame.Angles(math.rad(wheelieAngle), 0, 0)
			if bodyGyro and bodyGyro.Parent then bodyGyro.CFrame = targetCFrame end
			local currentTime = tick()
			if currentTime - lastHopTime >= modeSettings.BackHop.hopInterval then
				lastHopTime = currentTime
				local currentVel = mainPart.AssemblyLinearVelocity
				mainPart.AssemblyLinearVelocity = Vector3.new(currentVel.X, modeSettings.BackHop.hopPower, currentVel.Z)
			end
		end)
		return
	end

	if currentMode == "Frontflip" then
		motorcycle = findMotorcycle()
		if not motorcycle then return end
		local mainPart = motorcycle:FindFirstChild("MainPart") or motorcycle.PrimaryPart
		if not mainPart then return end
		local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
		bodyAngularVelocity.Name = "FlipVelocity"
		bodyAngularVelocity.MaxTorque = Vector3.new(math.huge, 0, 0)
		bodyAngularVelocity.AngularVelocity = Vector3.new(-modeSettings.Frontflip.speed, 0, 0)
		bodyAngularVelocity.P = 10000
		bodyAngularVelocity.Parent = mainPart
		bodyGyro = bodyAngularVelocity
		return
	end

	if currentMode == "AutoSteer" then
		autoSteerEnabled = true
		if autoSteerConnection then autoSteerConnection:Disconnect() end
		local frameCounter = 0
		local UPDATE_INTERVAL = 6
		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Exclude
		local cachedMotorcycle = nil
		local cachedMainPart = nil
		local lastCacheUpdate = 0
		local CACHE_UPDATE_INTERVAL = 30
		autoSteerConnection = RunService.Heartbeat:Connect(function(deltaTime)
			if not autoSteerEnabled then
				if autoSteerConnection then autoSteerConnection:Disconnect(); autoSteerConnection = nil end
				return
			end
			if not waypointPosition then return end
			frameCounter = frameCounter + 1
			if frameCounter < UPDATE_INTERVAL then return end
			frameCounter = 0
			lastCacheUpdate = lastCacheUpdate + 1
			if lastCacheUpdate >= CACHE_UPDATE_INTERVAL or not cachedMotorcycle or not cachedMainPart then
				cachedMotorcycle = findMotorcycle()
				if cachedMotorcycle then
					cachedMainPart = cachedMotorcycle:FindFirstChild("MainPart") or cachedMotorcycle.PrimaryPart
				end
				lastCacheUpdate = 0
			end
			if not cachedMotorcycle or not cachedMainPart then return end
			local velocity = cachedMainPart.AssemblyLinearVelocity
			if velocity.Magnitude < 3 then return end
			local directionToWaypoint = (waypointPosition - cachedMainPart.Position)
			local distanceToWaypoint = directionToWaypoint.Magnitude
			if distanceToWaypoint < 20 then
				if waypointMarker and waypointMarker.Parent then waypointMarker:Destroy() end
				waypointMarker = nil
				waypointPosition = nil
				return
			end
			local directionFlat = Vector3.new(directionToWaypoint.X, 0, directionToWaypoint.Z).Unit
			local targetDirection = directionFlat
			local currentVelocity = cachedMainPart.AssemblyLinearVelocity
			local horizontalSpeed = Vector3.new(currentVelocity.X, 0, currentVelocity.Z).Magnitude
			local targetLookAt = CFrame.lookAt(Vector3.new(0, 0, 0), targetDirection)
			local _, targetY, _ = targetLookAt:ToOrientation()
			local currentCFrame = cachedMainPart.CFrame
			local currentPitch, currentYaw, currentRoll = currentCFrame:ToOrientation()
			local currentPos = cachedMainPart.Position
			local newCFrame = CFrame.new(currentPos) * CFrame.Angles(currentPitch, targetY, currentRoll)
			cachedMotorcycle:PivotTo(newCFrame)
			rayParams.FilterDescendantsInstances = {character, cachedMotorcycle, waypointMarker}
			cachedMainPart.AssemblyLinearVelocity = Vector3.new(
				targetDirection.X * horizontalSpeed,
				currentVelocity.Y,
				targetDirection.Z * horizontalSpeed
			)
		end)
		return
	end

	-- Wheelie / Stoppie / SideWheelie
	motorcycle = findMotorcycle()
	if not motorcycle then return end
	local mainPart = motorcycle:FindFirstChild("MainPart") or motorcycle.PrimaryPart
	if not mainPart then return end
	if originalNeutralCFrame then
		local savedPos = originalNeutralCFrame.Position
		local currentPos = mainPart.Position
		if (savedPos - currentPos).Magnitude > 50 then originalNeutralCFrame = nil end
	end
	if not originalNeutralCFrame then originalNeutralCFrame = mainPart.CFrame end
	if not bodyGyro or not bodyGyro.Parent then
		bodyGyro = Instance.new("BodyGyro")
		bodyGyro.Name = "TrickGyro"
		bodyGyro.MaxTorque = Vector3.new(GYRO_POWER, GYRO_POWER, GYRO_POWER)
		bodyGyro.P = GYRO_POWER
		bodyGyro.D = GYRO_DAMPING
		bodyGyro.Parent = mainPart
	else
		if bodyGyro:IsA("BodyGyro") then
			bodyGyro.MaxTorque = Vector3.new(GYRO_POWER, GYRO_POWER, GYRO_POWER)
		end
	end
	if updateConnection then updateConnection:Disconnect() end
	local initialCFrame = mainPart.CFrame
	local _, initialY, _ = initialCFrame:ToOrientation()
	targetYRotation = initialY
	updateConnection = RunService.Heartbeat:Connect(function(deltaTime)
		if not isActive then
			if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
			if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy(); bodyGyro = nil end
			if bodyPosition and bodyPosition.Parent then bodyPosition:Destroy(); bodyPosition = nil end
			return
		end
		if not mainPart or not mainPart.Parent then
			if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
			return
		end
		local rotationInput = 0
		if UserInputService:IsKeyDown(Enum.KeyCode.A) or UserInputService:IsKeyDown(Enum.KeyCode.Left) then
			rotationInput = ROTATION_SPEED * deltaTime
		elseif UserInputService:IsKeyDown(Enum.KeyCode.D) or UserInputService:IsKeyDown(Enum.KeyCode.Right) then
			rotationInput = -ROTATION_SPEED * deltaTime
		end
		targetYRotation = targetYRotation + rotationInput
		local trickAngle = modeSettings[currentMode].angle
		local targetCFrame = CFrame.new(mainPart.Position) * CFrame.Angles(0, targetYRotation, 0)
		if currentMode == "Wheelie" then
			targetCFrame = targetCFrame * CFrame.Angles(math.rad(trickAngle), 0, 0)
		elseif currentMode == "Stoppie" then
			targetCFrame = targetCFrame * CFrame.Angles(math.rad(-trickAngle), 0, 0)
		elseif currentMode == "SideWheelie" then
			local tiltAngle = modeSettings.SideWheelie.tilt
			targetCFrame = targetCFrame * CFrame.Angles(math.rad(trickAngle), 0, math.rad(tiltAngle))
		end
		if bodyGyro and bodyGyro.Parent then
			bodyGyro.CFrame = targetCFrame
		else
			if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
		end
	end)
end

local function stopTrick()
	if currentMode == "BackHop" then
		if backHopConnection then backHopConnection:Disconnect(); backHopConnection = nil end
		if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
		bodyGyro = nil
		return
	end
	if currentMode == "AutoSteer" then
		autoSteerEnabled = false
		if autoSteerConnection then autoSteerConnection:Disconnect(); autoSteerConnection = nil end
		if waypointMarker and waypointMarker.Parent then waypointMarker:Destroy() end
		waypointMarker = nil
		waypointPosition = nil
		motorcycle = findMotorcycle()
		if motorcycle then
			local mainPart = motorcycle:FindFirstChild("MainPart") or motorcycle.PrimaryPart
			if mainPart then
				local g = mainPart:FindFirstChild("AutoSteerGyro")
				if g then g:Destroy() end
				local gf = mainPart:FindFirstChild("AutoSteerGravity")
				if gf then gf:Destroy() end
			end
		end
		return
	end
	if currentMode == "Backflip" or currentMode == "Frontflip" then
		if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
		bodyGyro = nil
		return
	end
	if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
	if motorcycle and originalNeutralCFrame then
		local mainPart = motorcycle:FindFirstChild("MainPart") or motorcycle.PrimaryPart
		if mainPart and bodyGyro and bodyGyro.Parent then
			local currentCFrame = mainPart.CFrame
			local _, origY, _ = originalNeutralCFrame:ToOrientation()
			local targetCFrame = CFrame.new(mainPart.Position) * CFrame.Angles(0, origY, 0)
			local startTime = tick()
			local tweenConn = nil
			tweenConn = RunService.Heartbeat:Connect(function()
				local elapsed = tick() - startTime
				local progress = math.min(elapsed / 0.3, 1)
				if progress >= 1 or not mainPart or not mainPart.Parent or not bodyGyro or not bodyGyro.Parent then
					if tweenConn then tweenConn:Disconnect() end
					if bodyGyro and bodyGyro.Parent and bodyGyro:IsA("BodyGyro") then
						bodyGyro.MaxTorque = Vector3.new(0, 0, 0)
					end
					return
				end
				bodyGyro.CFrame = currentCFrame:Lerp(targetCFrame, progress)
			end)
		end
	end
end

local function resetState()
	isActive = false
	motorcycle = nil
	bodyGyro = nil
	bodyPosition = nil
	originalNeutralCFrame = nil
	targetYRotation = 0
	if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
end

------------------------------------------------------
--             REVAMPED GUI                         --
------------------------------------------------------

-- Theme
local T = {
	Bg         = Color3.fromRGB(12, 12, 16),
	Surface    = Color3.fromRGB(20, 20, 26),
	Card       = Color3.fromRGB(26, 26, 34),
	CardHover  = Color3.fromRGB(34, 34, 44),
	Border     = Color3.fromRGB(38, 38, 50),
	Accent     = Color3.fromRGB(99, 102, 241),   -- Indigo
	AccentGlow = Color3.fromRGB(129, 132, 255),
	Text       = Color3.fromRGB(235, 235, 245),
	TextDim    = Color3.fromRGB(115, 115, 135),
	TextMuted  = Color3.fromRGB(75, 75, 95),
	Green      = Color3.fromRGB(52, 211, 153),
	Red        = Color3.fromRGB(248, 113, 113),
	Orange     = Color3.fromRGB(251, 191, 36),
	Pink       = Color3.fromRGB(244, 114, 182),
	Blue       = Color3.fromRGB(96, 165, 250),
	Cyan       = Color3.fromRGB(34, 211, 238),
	Purple     = Color3.fromRGB(167, 139, 250),
	Teal       = Color3.fromRGB(45, 212, 191),
}

-- Mode color map
local ModeColors = {
	Wheelie     = T.Green,
	Stoppie     = T.Orange,
	SideWheelie = T.Pink,
	BackHop     = T.Red,
	Jump        = T.Blue,
	Backflip    = T.Purple,
	Frontflip   = T.Teal,
	AutoSteer   = T.Cyan,
}

local ModeIcons = {
	Wheelie     = "W",
	Stoppie     = "S",
	SideWheelie = "SW",
	BackHop     = "BH",
	Jump        = "J",
	Backflip    = "BF",
	Frontflip   = "FF",
	AutoSteer   = "AS",
}

-- Utilities
local function tw(obj, props, dur, style, dir)
	return TweenService:Create(obj, TweenInfo.new(dur or 0.2, style or Enum.EasingStyle.Quint, dir or Enum.EasingDirection.Out), props)
end

local function corner(p, r)
	local c = Instance.new("UICorner"); c.CornerRadius = UDim.new(0, r or 8); c.Parent = p; return c
end

local function stroke(p, col, th)
	local s = Instance.new("UIStroke"); s.Color = col or T.Border; s.Thickness = th or 1; s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; s.Parent = p; return s
end

local function pad(p, t, b, l, r)
	local u = Instance.new("UIPadding")
	u.PaddingTop = UDim.new(0, t or 0); u.PaddingBottom = UDim.new(0, b or 0)
	u.PaddingLeft = UDim.new(0, l or 0); u.PaddingRight = UDim.new(0, r or 0)
	u.Parent = p; return u
end

-- Refs for external access
local statusLabelRef, updateSliderRef, switchModeRef

local function createGUI()
	-- ScreenGui
	local sg = Instance.new("ScreenGui")
	sg.Name = "MotorcycleTricksGUI"
	sg.ResetOnSpawn = false
	sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	sg.DisplayOrder = 10

	-- Main container
	local main = Instance.new("Frame")
	main.Name = "Main"
	main.Size = UDim2.new(0, 300, 0, 0) -- starts collapsed for animation
	main.Position = UDim2.new(0.5, -150, 0.5, 0)
	main.AnchorPoint = Vector2.new(0.5, 0.5)
	main.BackgroundColor3 = T.Bg
	main.BorderSizePixel = 0
	main.ClipsDescendants = true
	main.Parent = sg
	corner(main, 14)
	stroke(main, T.Border, 1)

	-- Outer glow/shadow
	local shadow = Instance.new("ImageLabel")
	shadow.Size = UDim2.new(1, 40, 1, 40)
	shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
	shadow.AnchorPoint = Vector2.new(0.5, 0.5)
	shadow.BackgroundTransparency = 1
	shadow.Image = "rbxassetid://5554236805"
	shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	shadow.ImageTransparency = 0.4
	shadow.ScaleType = Enum.ScaleType.Slice
	shadow.SliceCenter = Rect.new(23, 23, 277, 277)
	shadow.ZIndex = -1
	shadow.Parent = main

	----------------------------------------------
	-- HEADER
	----------------------------------------------
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 52)
	header.BackgroundColor3 = T.Surface
	header.BorderSizePixel = 0
	header.Parent = main
	corner(header, 14)
	-- Cover bottom corners
	local hCover = Instance.new("Frame")
	hCover.Size = UDim2.new(1, 0, 0, 16); hCover.Position = UDim2.new(0, 0, 1, -16)
	hCover.BackgroundColor3 = T.Surface; hCover.BorderSizePixel = 0; hCover.Parent = header

	-- Accent bar
	local accentBar = Instance.new("Frame")
	accentBar.Size = UDim2.new(1, 0, 0, 2)
	accentBar.Position = UDim2.new(0, 0, 1, 0)
	accentBar.BackgroundColor3 = T.Accent
	accentBar.BorderSizePixel = 0
	accentBar.Parent = header
	local accentGrad = Instance.new("UIGradient")
	accentGrad.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, T.Accent),
		ColorSequenceKeypoint.new(0.5, T.AccentGlow),
		ColorSequenceKeypoint.new(1, T.Accent),
	}
	accentGrad.Transparency = NumberSequence.new{
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(0.5, 0),
		NumberSequenceKeypoint.new(1, 0.4),
	}
	accentGrad.Parent = accentBar

	-- Title
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -100, 0, 20)
	titleLabel.Position = UDim2.new(0, 16, 0, 9)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "VEHICLE TRICKS"
	titleLabel.TextColor3 = T.Text
	titleLabel.TextSize = 15
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = header

	-- Subtitle
	local subLabel = Instance.new("TextLabel")
	subLabel.Size = UDim2.new(1, -100, 0, 14)
	subLabel.Position = UDim2.new(0, 16, 0, 30)
	subLabel.BackgroundTransparency = 1
	subLabel.Text = "by spookyie"
	subLabel.TextColor3 = T.TextMuted
	subLabel.TextSize = 10
	subLabel.Font = Enum.Font.Gotham
	subLabel.TextXAlignment = Enum.TextXAlignment.Left
	subLabel.Parent = header

	-- Header buttons container
	local hBtns = Instance.new("Frame")
	hBtns.Size = UDim2.new(0, 76, 0, 28)
	hBtns.Position = UDim2.new(1, -88, 0.5, -14)
	hBtns.BackgroundTransparency = 1
	hBtns.Parent = header

	local function headerBtn(name, text, col, posX)
		local b = Instance.new("TextButton")
		b.Name = name; b.Size = UDim2.new(0, 32, 0, 28)
		b.Position = UDim2.new(0, posX, 0, 0)
		b.BackgroundColor3 = col; b.BackgroundTransparency = 0.88
		b.Text = text; b.TextColor3 = col; b.TextSize = 13
		b.Font = Enum.Font.GothamBold; b.BorderSizePixel = 0
		b.AutoButtonColor = false; b.Parent = hBtns
		corner(b, 6)
		b.MouseEnter:Connect(function() tw(b, {BackgroundTransparency = 0.7}, 0.15):Play() end)
		b.MouseLeave:Connect(function() tw(b, {BackgroundTransparency = 0.88}, 0.15):Play() end)
		return b
	end

	local refreshBtn = headerBtn("Refresh", "R", T.Accent, 0)
	local minBtn = headerBtn("Min", "—", T.TextDim, 38)

	----------------------------------------------
	-- SCROLLING CONTENT
	----------------------------------------------
	local content = Instance.new("ScrollingFrame")
	content.Name = "Content"
	content.Size = UDim2.new(1, 0, 1, -52)
	content.Position = UDim2.new(0, 0, 0, 52)
	content.BackgroundTransparency = 1
	content.BorderSizePixel = 0
	content.ScrollBarThickness = 2
	content.ScrollBarImageColor3 = T.Accent
	content.ScrollBarImageTransparency = 0.5
	content.CanvasSize = UDim2.new(0, 0, 0, 0)
	content.AutomaticCanvasSize = Enum.AutomaticSize.Y
	content.Parent = main

	local layout = Instance.new("UIListLayout")
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 6)
	layout.Parent = content
	pad(content, 10, 10, 12, 12)

	----------------------------------------------
	-- SECTION: Trick Modes
	----------------------------------------------
	local modeLabel = Instance.new("TextLabel")
	modeLabel.Size = UDim2.new(1, 0, 0, 16)
	modeLabel.BackgroundTransparency = 1
	modeLabel.Text = "TRICKS"
	modeLabel.TextColor3 = T.TextMuted
	modeLabel.TextSize = 10
	modeLabel.Font = Enum.Font.GothamBold
	modeLabel.TextXAlignment = Enum.TextXAlignment.Left
	modeLabel.LayoutOrder = 1
	modeLabel.Parent = content

	-- Grid container for mode buttons
	local modeGrid = Instance.new("Frame")
	modeGrid.Name = "ModeGrid"
	modeGrid.Size = UDim2.new(1, 0, 0, 152)
	modeGrid.BackgroundTransparency = 1
	modeGrid.LayoutOrder = 2
	modeGrid.Parent = content

	local modeButtons = {}
	local modeOrder = {"Wheelie", "Stoppie", "SideWheelie", "BackHop", "Jump", "Backflip", "Frontflip", "AutoSteer"}
	local modeDisplayNames = {
		Wheelie = "Wheelie", Stoppie = "Stoppie", SideWheelie = "Side Wheelie",
		BackHop = "Back Hop", Jump = "Jump", Backflip = "Backflip",
		Frontflip = "Frontflip", AutoSteer = "Auto-Steer"
	}

	for i, mode in ipairs(modeOrder) do
		local col = math.floor((i - 1) % 2)
		local row = math.floor((i - 1) / 2)

		local btn = Instance.new("TextButton")
		btn.Name = mode
		btn.Size = UDim2.new(0.485, 0, 0, 32)
		btn.Position = UDim2.new(col * 0.515, 0, 0, row * 38)
		btn.BackgroundColor3 = T.Card
		btn.BorderSizePixel = 0
		btn.AutoButtonColor = false
		btn.Text = ""
		btn.Parent = modeGrid
		corner(btn, 8)
		stroke(btn, T.Border, 1)

		-- Icon circle
		local iconBg = Instance.new("Frame")
		iconBg.Size = UDim2.new(0, 22, 0, 22)
		iconBg.Position = UDim2.new(0, 8, 0.5, -11)
		iconBg.BackgroundColor3 = ModeColors[mode]
		iconBg.BackgroundTransparency = 0.85
		iconBg.BorderSizePixel = 0
		iconBg.Parent = btn
		corner(iconBg, 6)

		local iconLbl = Instance.new("TextLabel")
		iconLbl.Size = UDim2.new(1, 0, 1, 0)
		iconLbl.BackgroundTransparency = 1
		iconLbl.Text = ModeIcons[mode]
		iconLbl.TextColor3 = ModeColors[mode]
		iconLbl.TextSize = 12
		iconLbl.Font = Enum.Font.GothamBold
		iconLbl.Parent = iconBg

		-- Name
		local nameLbl = Instance.new("TextLabel")
		nameLbl.Size = UDim2.new(1, -40, 1, 0)
		nameLbl.Position = UDim2.new(0, 36, 0, 0)
		nameLbl.BackgroundTransparency = 1
		nameLbl.Text = modeDisplayNames[mode]
		nameLbl.TextColor3 = T.TextDim
		nameLbl.TextSize = 11
		nameLbl.Font = Enum.Font.GothamBold
		nameLbl.TextXAlignment = Enum.TextXAlignment.Left
		nameLbl.TextTruncate = Enum.TextTruncate.AtEnd
		nameLbl.Parent = btn

		-- Active indicator dot
		local dot = Instance.new("Frame")
		dot.Name = "Dot"
		dot.Size = UDim2.new(0, 5, 0, 5)
		dot.Position = UDim2.new(1, -12, 0.5, -2.5)
		dot.BackgroundColor3 = ModeColors[mode]
		dot.BackgroundTransparency = 1
		dot.BorderSizePixel = 0
		dot.Parent = btn
		corner(dot, 3)

		-- Hover
		btn.MouseEnter:Connect(function()
			if currentMode ~= mode then
				tw(btn, {BackgroundColor3 = T.CardHover}, 0.15):Play()
			end
		end)
		btn.MouseLeave:Connect(function()
			if currentMode ~= mode then
				tw(btn, {BackgroundColor3 = T.Card}, 0.15):Play()
			end
		end)

		modeButtons[mode] = {button = btn, nameLbl = nameLbl, iconBg = iconBg, iconLbl = iconLbl, dot = dot}
	end

	----------------------------------------------
	-- SECTION: Slider
	----------------------------------------------
	local sliderSection = Instance.new("Frame")
	sliderSection.Name = "SliderSection"
	sliderSection.Size = UDim2.new(1, 0, 0, 50)
	sliderSection.BackgroundColor3 = T.Card
	sliderSection.BorderSizePixel = 0
	sliderSection.LayoutOrder = 3
	sliderSection.Parent = content
	corner(sliderSection, 8)
	stroke(sliderSection, T.Border, 1)

	local sliderLabel = Instance.new("TextLabel")
	sliderLabel.Name = "SliderLabel"
	sliderLabel.Size = UDim2.new(1, -20, 0, 14)
	sliderLabel.Position = UDim2.new(0, 10, 0, 6)
	sliderLabel.BackgroundTransparency = 1
	sliderLabel.Text = "Angle: 45°"
	sliderLabel.TextColor3 = T.TextDim
	sliderLabel.TextSize = 10
	sliderLabel.Font = Enum.Font.GothamMedium
	sliderLabel.TextXAlignment = Enum.TextXAlignment.Left
	sliderLabel.Parent = sliderSection

	local sliderValueLabel = Instance.new("TextLabel")
	sliderValueLabel.Size = UDim2.new(0, 50, 0, 14)
	sliderValueLabel.Position = UDim2.new(1, -60, 0, 6)
	sliderValueLabel.BackgroundTransparency = 1
	sliderValueLabel.Text = "45"
	sliderValueLabel.TextColor3 = T.Green
	sliderValueLabel.TextSize = 11
	sliderValueLabel.Font = Enum.Font.GothamBold
	sliderValueLabel.TextXAlignment = Enum.TextXAlignment.Right
	sliderValueLabel.Parent = sliderSection

	-- Slider track
	local sliderTrack = Instance.new("Frame")
	sliderTrack.Name = "Track"
	sliderTrack.Size = UDim2.new(1, -24, 0, 4)
	sliderTrack.Position = UDim2.new(0, 12, 0, 30)
	sliderTrack.BackgroundColor3 = T.Bg
	sliderTrack.BorderSizePixel = 0
	sliderTrack.Active = true
	sliderTrack.Parent = sliderSection
	corner(sliderTrack, 2)

	local sliderFill = Instance.new("Frame")
	sliderFill.Name = "Fill"
	sliderFill.Size = UDim2.new(0.5, 0, 1, 0)
	sliderFill.BackgroundColor3 = T.Green
	sliderFill.BorderSizePixel = 0
	sliderFill.Parent = sliderTrack
	corner(sliderFill, 2)

	-- Slider knob
	local sliderKnob = Instance.new("Frame")
	sliderKnob.Name = "Knob"
	sliderKnob.Size = UDim2.new(0, 14, 0, 14)
	sliderKnob.Position = UDim2.new(0.5, -7, 0, 25)
	sliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	sliderKnob.BorderSizePixel = 0
	sliderKnob.Active = true
	sliderKnob.ZIndex = 3
	sliderKnob.Parent = sliderSection
	corner(sliderKnob, 7)
	local knobStroke = stroke(sliderKnob, T.Green, 2)

	----------------------------------------------
	-- SECTION: Settings Toggles
	----------------------------------------------
	local settLabel = Instance.new("TextLabel")
	settLabel.Size = UDim2.new(1, 0, 0, 16)
	settLabel.BackgroundTransparency = 1
	settLabel.Text = "SETTINGS"
	settLabel.TextColor3 = T.TextMuted
	settLabel.TextSize = 10
	settLabel.Font = Enum.Font.GothamBold
	settLabel.TextXAlignment = Enum.TextXAlignment.Left
	settLabel.LayoutOrder = 4
	settLabel.Parent = content

	local function createToggle(text, order, defaultState, onChange)
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, 0, 0, 32)
		row.BackgroundColor3 = T.Card
		row.BorderSizePixel = 0
		row.LayoutOrder = order
		row.Parent = content
		corner(row, 8)
		stroke(row, T.Border, 1)

		local lbl = Instance.new("TextLabel")
		lbl.Size = UDim2.new(1, -60, 1, 0)
		lbl.Position = UDim2.new(0, 12, 0, 0)
		lbl.BackgroundTransparency = 1
		lbl.Text = text
		lbl.TextColor3 = T.TextDim
		lbl.TextSize = 11
		lbl.Font = Enum.Font.GothamMedium
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.Parent = row

		-- Toggle switch
		local toggleBg = Instance.new("TextButton")
		toggleBg.Size = UDim2.new(0, 36, 0, 18)
		toggleBg.Position = UDim2.new(1, -48, 0.5, -9)
		toggleBg.BackgroundColor3 = defaultState and T.Accent or Color3.fromRGB(45, 45, 55)
		toggleBg.BorderSizePixel = 0
		toggleBg.Text = ""
		toggleBg.AutoButtonColor = false
		toggleBg.Parent = row
		corner(toggleBg, 9)

		local toggleDot = Instance.new("Frame")
		toggleDot.Size = UDim2.new(0, 14, 0, 14)
		toggleDot.Position = defaultState and UDim2.new(1, -16, 0.5, -7) or UDim2.new(0, 2, 0.5, -7)
		toggleDot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		toggleDot.BorderSizePixel = 0
		toggleDot.Parent = toggleBg
		corner(toggleDot, 7)

		local state = defaultState or false

		local function setToggle(val)
			state = val
			if state then
				tw(toggleBg, {BackgroundColor3 = T.Accent}, 0.2):Play()
				tw(toggleDot, {Position = UDim2.new(1, -16, 0.5, -7)}, 0.2):Play()
			else
				tw(toggleBg, {BackgroundColor3 = Color3.fromRGB(45, 45, 55)}, 0.2):Play()
				tw(toggleDot, {Position = UDim2.new(0, 2, 0.5, -7)}, 0.2):Play()
			end
		end

		toggleBg.MouseButton1Click:Connect(function()
			setToggle(not state)
			if onChange then onChange(state) end
		end)

		return toggleBg, function() return state end, setToggle
	end

	local mouseWheelToggle, getMouseWheel, setMouseWheel = createToggle("Mouse Wheel Angle", 5, false, function(newState)
		mouseWheelControlEnabled = newState
	end)
	local autoSwitchToggle, getAutoSwitch, setAutoSwitch = createToggle("Alt Switch (Wheelie / Stoppie)", 6, false, function(newState)
		autoSwitchEnabled = newState
	end)

	-- Keybind button
	local keybindRow = Instance.new("Frame")
	keybindRow.Size = UDim2.new(1, 0, 0, 32)
	keybindRow.BackgroundColor3 = T.Card
	keybindRow.BorderSizePixel = 0
	keybindRow.LayoutOrder = 7
	keybindRow.Parent = content
	corner(keybindRow, 8)
	stroke(keybindRow, T.Border, 1)

	local keybindLbl = Instance.new("TextLabel")
	keybindLbl.Size = UDim2.new(1, -80, 1, 0)
	keybindLbl.Position = UDim2.new(0, 12, 0, 0)
	keybindLbl.BackgroundTransparency = 1
	keybindLbl.Text = "Activation Key"
	keybindLbl.TextColor3 = T.TextDim
	keybindLbl.TextSize = 11
	keybindLbl.Font = Enum.Font.GothamMedium
	keybindLbl.TextXAlignment = Enum.TextXAlignment.Left
	keybindLbl.Parent = keybindRow

	local keybindBtn = Instance.new("TextButton")
	keybindBtn.Size = UDim2.new(0, 56, 0, 20)
	keybindBtn.Position = UDim2.new(1, -66, 0.5, -10)
	keybindBtn.BackgroundColor3 = T.Bg
	keybindBtn.BorderSizePixel = 0
	keybindBtn.Text = "CTRL"
	keybindBtn.TextColor3 = T.Accent
	keybindBtn.TextSize = 10
	keybindBtn.Font = Enum.Font.GothamBold
	keybindBtn.AutoButtonColor = false
	keybindBtn.Parent = keybindRow
	corner(keybindBtn, 5)
	stroke(keybindBtn, T.Accent, 1)

	----------------------------------------------
	-- STATUS BAR
	----------------------------------------------
	local statusBar = Instance.new("Frame")
	statusBar.Size = UDim2.new(1, 0, 0, 30)
	statusBar.BackgroundColor3 = T.Surface
	statusBar.BackgroundTransparency = 0.5
	statusBar.BorderSizePixel = 0
	statusBar.LayoutOrder = 10
	statusBar.Parent = content
	corner(statusBar, 8)

	-- Status dot
	local statusDot = Instance.new("Frame")
	statusDot.Size = UDim2.new(0, 6, 0, 6)
	statusDot.Position = UDim2.new(0, 12, 0.5, -3)
	statusDot.BackgroundColor3 = T.TextMuted
	statusDot.BorderSizePixel = 0
	statusDot.Parent = statusBar
	corner(statusDot, 3)

	local statusLabel = Instance.new("TextLabel")
	statusLabel.Name = "Status"
	statusLabel.Size = UDim2.new(1, -30, 1, 0)
	statusLabel.Position = UDim2.new(0, 24, 0, 0)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Text = "Press CTRL to activate"
	statusLabel.TextColor3 = T.TextMuted
	statusLabel.TextSize = 10
	statusLabel.Font = Enum.Font.GothamMedium
	statusLabel.TextXAlignment = Enum.TextXAlignment.Left
	statusLabel.Parent = statusBar
	statusLabelRef = statusLabel

	----------------------------------------------
	-- SLIDER LOGIC
	----------------------------------------------
	local function updateSlider(value)
		local mode = modeSettings[currentMode]
		local col = ModeColors[currentMode] or T.Accent
		local labelText, displayVal
		local normalized = 0

		if currentMode == "Wheelie" or currentMode == "Stoppie" then
			normalized = math.clamp((value - mode.minAngle) / (mode.maxAngle - mode.minAngle), 0, 1)
			labelText = currentMode .. " Angle"
			displayVal = math.floor(value) .. "°"
			mode.angle = value
		elseif currentMode == "SideWheelie" then
			normalized = math.clamp((value - mode.minTilt) / (mode.maxTilt - mode.minTilt), 0, 1)
			labelText = "Side Tilt"
			displayVal = math.floor(value) .. "°"
			mode.tilt = value
		elseif currentMode == "BackHop" then
			normalized = math.clamp((value - mode.minHopPower) / (mode.maxHopPower - mode.minHopPower), 0, 1)
			labelText = "Hop Power"
			displayVal = tostring(math.floor(value))
			mode.hopPower = value
		elseif currentMode == "Jump" then
			normalized = math.clamp((value - mode.minPower) / (mode.maxPower - mode.minPower), 0, 1)
			labelText = "Jump Power"
			displayVal = tostring(math.floor(value))
			mode.power = value
		elseif currentMode == "Backflip" or currentMode == "Frontflip" then
			normalized = math.clamp((value - mode.minSpeed) / (mode.maxSpeed - mode.minSpeed), 0, 1)
			labelText = currentMode .. " Speed"
			displayVal = tostring(math.floor(value * 10) / 10)
			mode.speed = value
		elseif currentMode == "AutoSteer" then
			sliderSection.Visible = false
			return
		end

		sliderSection.Visible = true
		sliderFill.Size = UDim2.new(normalized, 0, 1, 0)
		sliderFill.BackgroundColor3 = col
		sliderKnob.Position = UDim2.new(0, 12 + normalized * (sliderSection.AbsoluteSize.X - 24 - 14), 0, 25)
		knobStroke.Color = col
		sliderLabel.Text = labelText
		sliderValueLabel.Text = displayVal
		sliderValueLabel.TextColor3 = col
	end
	updateSliderRef = updateSlider

	-- Slider interaction
	local sliderDragging = false

	local function handleSliderInput()
		local mousePos = UserInputService:GetMouseLocation()
		local trackPos = sliderTrack.AbsolutePosition
		local trackSize = sliderTrack.AbsoluteSize
		local normalizedX = math.clamp((mousePos.X - trackPos.X) / trackSize.X, 0, 1)
		local mode = modeSettings[currentMode]

		if currentMode == "Wheelie" or currentMode == "Stoppie" then
			updateSlider(mode.minAngle + normalizedX * (mode.maxAngle - mode.minAngle))
		elseif currentMode == "SideWheelie" then
			updateSlider(mode.minTilt + normalizedX * (mode.maxTilt - mode.minTilt))
		elseif currentMode == "BackHop" then
			updateSlider(mode.minHopPower + normalizedX * (mode.maxHopPower - mode.minHopPower))
		elseif currentMode == "Jump" then
			updateSlider(mode.minPower + normalizedX * (mode.maxPower - mode.minPower))
		elseif currentMode == "Backflip" or currentMode == "Frontflip" then
			updateSlider(mode.minSpeed + normalizedX * (mode.maxSpeed - mode.minSpeed))
		end
	end

	sliderTrack.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			sliderDragging = true
			handleSliderInput()
		end
	end)

	sliderKnob.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			sliderDragging = true
		end
	end)

	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			sliderDragging = false
		end
	end)

	RunService.RenderStepped:Connect(function()
		if sliderDragging then handleSliderInput() end
	end)

	----------------------------------------------
	-- MODE SWITCHING
	----------------------------------------------
	local function switchMode(mode)
		currentMode = mode
		local col = ModeColors[mode] or T.Accent

		-- Reset all buttons
		for m, refs in pairs(modeButtons) do
			local isActive = (m == mode)
			local c = ModeColors[m]
			tw(refs.button, {BackgroundColor3 = isActive and c or T.Card}, 0.2):Play()
			refs.button.BackgroundTransparency = isActive and 0.85 or 0
			tw(refs.nameLbl, {TextColor3 = isActive and T.Text or T.TextDim}, 0.2):Play()
			tw(refs.dot, {BackgroundTransparency = isActive and 0 or 1}, 0.2):Play()
			-- Update stroke
			local s = refs.button:FindFirstChildOfClass("UIStroke")
			if s then tw(s, {Color = isActive and c or T.Border}, 0.2):Play() end
		end

		-- Update slider
		if mode == "Wheelie" then updateSlider(modeSettings.Wheelie.angle)
		elseif mode == "Stoppie" then updateSlider(modeSettings.Stoppie.angle)
		elseif mode == "SideWheelie" then updateSlider(modeSettings.SideWheelie.tilt)
		elseif mode == "BackHop" then updateSlider(modeSettings.BackHop.hopPower)
		elseif mode == "Jump" then updateSlider(modeSettings.Jump.power)
		elseif mode == "Backflip" then updateSlider(modeSettings.Backflip.speed)
		elseif mode == "Frontflip" then updateSlider(modeSettings.Frontflip.speed)
		elseif mode == "AutoSteer" then sliderSection.Visible = false
		end
	end
	switchModeRef = switchMode

	-- Wire up mode buttons
	for mode, refs in pairs(modeButtons) do
		refs.button.MouseButton1Click:Connect(function() switchMode(mode) end)
	end

	----------------------------------------------
	-- TOGGLE CALLBACKS
	----------------------------------------------
	keybindBtn.MouseButton1Click:Connect(function()
		if activationKey == Enum.KeyCode.LeftControl then
			activationKey = Enum.KeyCode.LeftShift
			keybindBtn.Text = "SHIFT"
			statusLabel.Text = "Press SHIFT to activate"
		else
			activationKey = Enum.KeyCode.LeftControl
			keybindBtn.Text = "CTRL"
			statusLabel.Text = "Press CTRL to activate"
		end
	end)

	----------------------------------------------
	-- REFRESH
	----------------------------------------------
	refreshBtn.MouseButton1Click:Connect(function()
		-- Reset all state
		isActive = false; motorcycle = nil; originalNeutralCFrame = nil; targetYRotation = 0
		if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end; bodyGyro = nil
		if bodyPosition and bodyPosition.Parent then bodyPosition:Destroy() end; bodyPosition = nil
		if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
		autoSteerEnabled = false
		if autoSteerConnection then autoSteerConnection:Disconnect(); autoSteerConnection = nil end
		if waypointMarker and waypointMarker.Parent then waypointMarker:Destroy() end
		waypointMarker = nil; waypointPosition = nil

		-- Fade OUT
		tw(main, {BackgroundTransparency = 0.7}, 0.2):Play()
		for _, child in ipairs(main:GetDescendants()) do
			if child:IsA("TextLabel") or child:IsA("TextButton") then
				tw(child, {TextTransparency = 0.7}, 0.2):Play()
			end
			if child:IsA("Frame") and child.BackgroundTransparency < 0.8 and child.Name ~= "Fill" then
				tw(child, {BackgroundTransparency = 0.7}, 0.2):Play()
			end
			if child:IsA("ImageLabel") then
				tw(child, {ImageTransparency = 0.9}, 0.2):Play()
			end
		end

		task.wait(0.25)

		-- Fade IN
		tw(main, {BackgroundTransparency = 0}, 0.25):Play()
		for _, child in ipairs(main:GetDescendants()) do
			if child:IsA("TextLabel") then
				tw(child, {TextTransparency = 0}, 0.25):Play()
			elseif child:IsA("TextButton") then
				tw(child, {TextTransparency = 0}, 0.25):Play()
			end
			if child:IsA("ImageLabel") and child.Name == "Shadow" then
				tw(child, {ImageTransparency = 0.4}, 0.25):Play()
			end
		end

		-- Re-apply correct transparencies for mode buttons after fade
		task.wait(0.3)
		if switchModeRef then switchModeRef(currentMode) end
	end)

	----------------------------------------------
	-- MINIMIZE / DRAG
	----------------------------------------------
	local minimized = false
	local TARGET_HEIGHT = 520

	-- Dragging
	local dragging, dragStart, startPos = false, nil, nil

	header.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true; dragStart = input.Position; startPos = main.Position
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			local delta = input.Position - dragStart
			main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)

	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)

	minBtn.MouseButton1Click:Connect(function()
		minimized = not minimized
		if minimized then
			tw(main, {Size = UDim2.new(0, 300, 0, 52)}, 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In):Play()
		else
			tw(main, {Size = UDim2.new(0, 300, 0, TARGET_HEIGHT)}, 0.35, Enum.EasingStyle.Back):Play()
		end
	end)

	-- M key toggle
	UserInputService.InputBegan:Connect(function(input, gp)
		if gp then return end
		if input.KeyCode == Enum.KeyCode.M then
			minimized = not minimized
			if minimized then
				tw(main, {Size = UDim2.new(0, 300, 0, 52)}, 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In):Play()
			else
				tw(main, {Size = UDim2.new(0, 300, 0, TARGET_HEIGHT)}, 0.35, Enum.EasingStyle.Back):Play()
			end
		end
	end)

	----------------------------------------------
	-- OPEN ANIMATION
	----------------------------------------------
	main.BackgroundTransparency = 1
	main.Size = UDim2.new(0, 300, 0, 0)
	sg.Parent = player:WaitForChild("PlayerGui")

	task.wait(0.05)
	tw(main, {Size = UDim2.new(0, 300, 0, TARGET_HEIGHT), BackgroundTransparency = 0}, 0.45, Enum.EasingStyle.Back):Play()

	-- Initialize mode
	switchMode("Wheelie")

	----------------------------------------------
	-- STATUS UPDATE FUNCTION
	----------------------------------------------
	local function updateStatus(active)
		local col = ModeColors[currentMode] or T.Accent
		if active then
			statusLabel.Text = currentMode:upper() .. " ACTIVE"
			statusLabel.TextColor3 = col
			statusDot.BackgroundColor3 = col
		else
			if currentMode == "AutoSteer" then
				statusLabel.Text = "Click to set waypoint"
				statusLabel.TextColor3 = T.Cyan
				statusDot.BackgroundColor3 = T.Cyan
			else
				local keyName = activationKey == Enum.KeyCode.LeftControl and "CTRL" or "SHIFT"
				statusLabel.Text = "Press " .. keyName .. " to activate"
				statusLabel.TextColor3 = T.TextMuted
				statusDot.BackgroundColor3 = T.TextMuted
			end
		end
	end

	return updateStatus
end

------------------------------------------------------
--                 INIT & INPUT                     --
------------------------------------------------------

local updateStatus = createGUI()

-- Input handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	-- Waypoint placement for AutoSteer
	if input.UserInputType == Enum.UserInputType.MouseButton1 and currentMode == "AutoSteer" then
		local mouse = player:GetMouse()
		local camera = workspace.CurrentCamera
		local mouseRay = camera:ScreenPointToRay(mouse.X, mouse.Y)
		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Exclude
		rayParams.FilterDescendantsInstances = {character}
		rayParams.IgnoreWater = true
		local rayOrigin = mouseRay.Origin
		local rayDirection = mouseRay.Direction * 1000
		local hitPosition = nil
		local maxAttempts = 10
		for i = 1, maxAttempts do
			local rayResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)
			if not rayResult then break end
			if rayResult.Instance.Transparency <= 0.1 then
				hitPosition = rayResult.Position; break
			else
				local f = rayParams.FilterDescendantsInstances
				table.insert(f, rayResult.Instance)
				rayParams.FilterDescendantsInstances = f
			end
		end
		if hitPosition then
			local groundRayParams = RaycastParams.new()
			groundRayParams.FilterType = Enum.RaycastFilterType.Exclude
			groundRayParams.FilterDescendantsInstances = {character}
			local finalPosition = hitPosition
			for i = 1, maxAttempts do
				local groundRay = workspace:Raycast(hitPosition, Vector3.new(0, -500, 0), groundRayParams)
				if not groundRay then break end
				if groundRay.Instance.Transparency <= 0.1 then
					finalPosition = groundRay.Position + Vector3.new(0, 2, 0); break
				else
					local f = groundRayParams.FilterDescendantsInstances
					table.insert(f, groundRay.Instance)
					groundRayParams.FilterDescendantsInstances = f
				end
			end
			waypointPosition = finalPosition
			if waypointMarker and waypointMarker.Parent then waypointMarker:Destroy() end
			waypointMarker = Instance.new("Part")
			waypointMarker.Name = "WaypointMarker"
			waypointMarker.Size = Vector3.new(2, 5, 2)
			waypointMarker.Position = waypointPosition + Vector3.new(0, 2.5, 0)
			waypointMarker.Anchored = true
			waypointMarker.CanCollide = false
			waypointMarker.Material = Enum.Material.Neon
			waypointMarker.Color = Color3.fromRGB(34, 211, 238)
			waypointMarker.Transparency = 0.4
			waypointMarker.Parent = workspace
			local pl = Instance.new("PointLight")
			pl.Brightness = 1.5; pl.Range = 15
			pl.Color = Color3.fromRGB(34, 211, 238)
			pl.Parent = waypointMarker
			doTrick()
			updateStatus(true)
			return
		end
	end

	if input.KeyCode == activationKey then
		isActive = true
		doTrick()
		updateStatus(true)
	end

	if input.KeyCode == Enum.KeyCode.LeftAlt and autoSwitchEnabled then
		if currentMode == "Wheelie" then
			currentMode = "Stoppie"
		elseif currentMode == "Stoppie" then
			currentMode = "Wheelie"
		end
		if switchModeRef then switchModeRef(currentMode) end
		if isActive then
			stopTrick()
			doTrick()
		end
	end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
	if input.KeyCode == activationKey then
		isActive = false
		stopTrick()
		updateStatus(false)
	end
end)

-- Mouse wheel angle control
UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.UserInputType == Enum.UserInputType.MouseWheel and mouseWheelControlEnabled then
		if currentMode == "Wheelie" or currentMode == "Stoppie" then
			local mode = modeSettings[currentMode]
			local scrollDir = input.Position.Z
			local newAngle = math.clamp(mode.angle + scrollDir * MOUSE_WHEEL_SENSITIVITY, mode.minAngle, mode.maxAngle)
			mode.angle = newAngle
			if updateSliderRef then updateSliderRef(newAngle) end
		elseif currentMode == "SideWheelie" then
			local mode = modeSettings.SideWheelie
			local scrollDir = input.Position.Z
			local newTilt = math.clamp(mode.tilt + scrollDir * MOUSE_WHEEL_SENSITIVITY, mode.minTilt, mode.maxTilt)
			mode.tilt = newTilt
			if updateSliderRef then updateSliderRef(newTilt) end
		end
	end
end)

-- Cleanup
character.Humanoid.Died:Connect(function()
	if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
	stopTrick()
	resetState()
end)

player.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	humanoidRootPart = character:WaitForChild("HumanoidRootPart")
	resetState()
	character.Humanoid.Died:Connect(function()
		if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
		stopTrick()
		resetState()
	end)
end)

print("✅ Vehicle Tricks loaded!")
